---
title: 'Fundamentals of Scientific Computing: R'
author: "UC Davis Bioinformatics Core"
date: "`r Sys.Date()`"
output:
  html_document:
    keep_md: TRUE
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# RStudio and R notebooks

While all of the code functions from the command line, we recommend using RStudio for these course materials.

**Launch RStudio.**

## RStudio

RStudio is a convenient integrated development environment (IDE) for R. It provides a number of features that improve the experience of learning to the basics of R.

Your RStudio window should look something like this:

![New Rstudio session](tidyverse_2022/rstudio-1.png)

### The console

On the left hand side is the *console*. This is a command-line interface for R. Type a command, press enter to run it, and the result appears below.

![Running a simple command](tidyverse_2022/rstudio-2.png)
For now, ignore the `[1]` at the beginning of the line. We will come back to it in a later section.

In R, the prompt is a `>` character. At the beginning of the line, it indicates that R is ready for your next command.

In these materials, code appears in gray boxes, like this:

```{r, eval=FALSE}
1 + 1
```

Whenever you see one of these boxes, run the code yourself.

What happens if you press enter before you meant to?

```{r, eval=FALSE}
1 + 
```


![An incomplete command](tidyverse_2022/rstudio-3.png)

If you press enter before finishing a command, the next line will begin with a `+` character. This lets you know that R is expecting more input.

### The workspace browser

In the upper right panel is the *workspace (or environment) browser*. This window shows the objects present in the environment. Currently there are none.

Objects are data stored in memory. The following code adds an object to the workspace.

```{r, eval=FALSE}
a <- 1 + 1
```

**Run the code in the gray box above.**

![Assigning output](tidyverse_2022/rstudio-4.png)

Unlike the first time we ran `1 + 1`, nothing is printed to the console.

![Workspace browser](tidyverse_2022/rstudio-5.png)
Instead, a new value appears in the workspace browser.

Why? The `<-` is a special pair of characters called the *assignment operator* that stores the result of the addition in the *object* referred to on the left-hand side of the "arrow." If no object with the name exists, one is created.

![Evaluating a variable](tidyverse_2022/rstudio-6.png)

R evaluates the object and returns its value, 2. Objects retain their values until removed or reassigned.

The `<-` character pair is one of two assignment operators in R. In most situations, it is equivalent to the `=` character, but there are some exceptions, which we will address when they come up. This documentation follows the R convention of using `<-` in most cases.

### Help documentation

The lower right pane contains the file browser, plot viewer, and help documentation, which we will be using frequently.

## R notebooks

**Create a new R notebook using the menu bar at the top: File \> New File \> R Notebook.**

A fourth pane will open up containing a template R notebook. It should look something like this:

![An R Notebook](tidyverse_2022/rstudio-7.png)

R notebooks are a special type of *markdown* document. They combine executable code, its output, and text. Markdown syntax is used to encode formatting like headings, bold or italic fonts, bullet points, links, and more. Using an R notebook keeps code, figures, and written commentary together, making it easy to generate a report with a single click.

Within a notebook, code is organized into chunks, which separates the text R will evaluate from any notes or images included in the notebook.

New chunks are added by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I* on Windows, or *Cmd+Option+I* on Mac.

Code chunks are executed by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter* on Windows, or *Cmd+Shift+Enter* on Mac. You can run a single line of code by placing your cursor anywhere on the line and pressing *Ctrl+Enter* on Windows, or *Cmd+Enter* on Mac.

**Create and run a new chunk with the following code:**

```{r, eval=FALSE}
2 + 2
b <- 3 + 3
```

What happened? Where did the output for each line of code go?

**Set up a folder for the course, and save your notebook.**

Create a folder to contain all of the files for this course. 

Directories (folders) and the files they contain should be named without spaces or special characters. Using only alphanumeric characters, dots, dashes, and underscores ensures that most programming languages will be able to understand the name of your file without any problems. *If you use special characters like dollar signs, slashes, quotation marks, spaces, or parentheses, this is not always the case.*

Save your R notebook to your new folder.

# Importing and exporting data

For the remainder of this course, we will be working with a single data set to answer a number of simple biological questions about the effects of maternal cigarette use during pregnancy. This data is a table of parental and newborn birth weights adapted from a data set provided by [Mathematics and Statistics Help at the University of Sheffield](https://www.sheffield.ac.uk/mash/statistics/datasets). It has been slightly modified to allow us to demonstrate a few more functions, but the data is largely unchanged.

**Begin by setting up a working directory for this course.**

We're going to do all the work for this course in the directory we created in the last section. To make things easier, we'll set R's working directory to the directory where we saved our notebook. To do this, select the "Session" menu in the toolbar, then navigate to "Set Working Directory," and click on "Choose Directory." Choose the directory in which you saved your notebook.

When you do so, you should see that a line of code ran in your console:

```{r, eval=FALSE}
setwd("/Users/hannah/Desktop/intro_R/")
```

This is the GUI at work! When you clicked on a directory in the file browser, R was actually running the code displayed in your console. In the future, you can set your working directory that way instead.

**Download the data.**

```{r}
download.file("https://raw.githubusercontent.com/ucdavis-bioinformatics-training/2022_February_Introduction_to_R_for_Bioinformatics/main/birthweight.csv", "birthweight.csv")
```

## Import data using read.csv()

Manual data entry is time-consuming and leads to errors. R has a number of functions for reading data in a variety of formats. Let's use the `read.csv()` function to read in a spreadsheet containing data from an experiment.

```{r}
birthweight <- read.csv("birthweight.csv")
```

CSV stands for "comma separated value," and the CSV file is simply a text file where each row in the file represents a row in the data table, and the columns are separated by commas. The contents of the CSV file are now stored in the variable "birthweight."

## Export data using write.csv()

In the course of our analysis, we will add metrics to this data set. When we're finished, we will want to be able to save our analyses. To write the contents of the birthweight object to a new CSV, we can use the `write.csv()` function.

```{r, eval=FALSE}
write.csv(birthweight, file = "new_birthweight.csv")
```

The similar `read.delim()` and `write.delim()` can be used to read and write tab-delimited files, where columns are separated by tab characters rather than commas.

# Data frames

## Structure of a data frame

What is the birthweight object? In the environment browser, you should see that it is "42 obs. of 18 variables." It's probably a data table with 42 rows and 18 columns. We can verify this using the `class()` and `dim()` functions.

```{r}
class(birthweight)
dim(birthweight)
```

**A note on formatting:** In this documentation lines beginning with `##` are the output of the R code shown. Running `dim(birthweight)` asked R what the dimensions of the birthweight object are; the answer is 42 (rows) x 21 (columns). The "[1]" is not part of the output. It is an index added by R to help you keep track of the values when an operation outputs a large number of values. We will see other examples later that will hopefully make this more clear. For now, we can safely ignore that "[1]".

A data frame organizes data into rows and columns. The object must be "rectangular," with all rows having the same number of fields, and all values in a column must be of the same type.

Each column of a data frame is a *vector*. A vector is an ordered collection of values of the same type.

Let's take a look at the contents.

```{r, eval=FALSE}
birthweight
```

```{r, echo=FALSE}
library(kableExtra)
knitr::kable(
  birthweight,
  booktabs = TRUE,
  caption = 'The birthweight data set.'
) %>%
  kable_styling("striped") %>%
  scroll_box(width = "100%", height = "500px")
```

The data frame format should look familiar. It's a lot like a spreadsheet.

Generally, we don't want to operate on the entire data frame. For example, to calculate the mean birth weight, we don't need the information in the "paternal.education" column.

There are three ways to have R subset the data frame: `$`, `[[`, and `[`.

## Selecting a single column using the \$ and \[\[ operators

The simplest way to get all the values in the "birthweight" column is with the `$` operator.

```{r}
birthweight$birthweight
```

Notice that there are now three numbers inside brackets: one at the beginning of each line of output. These are the indices (locations) of the following number within the output vector. They give us a general idea of the length of the vector, and allow us to determine the value of a particular observation at a glance. For example, we can answer the question "what was the birth weight of the 34th baby?"

Once the vector of birth weights has been extracted from the rest of the data frame, it can be used to calculate a mean.

```{r}
mean(birthweight$birthweight)
```

This `$` operator is a shortcut for the `[[` sub-setting operator, which requires typing six characters (two pairs of square brackets and a pair of quotation marks) rather than just one (the dollar sign). They function in the same way, returning the value of the element named.

```{r}
birthweight[["birthweight"]]
mean(birthweight[["birthweight"]])
```

One difference to note is that while `[[` works with the index, or column number, `$` does not.

```{r}
# which column contains the birth weight?
# lines beginning with a '#' are comments, and are not executed by R
colnames(birthweight)
birthweight[[5]]
mean(birthweight[[5]])
```

```{r, eval=FALSE}
# the $ operator can't take an index
birthweight$5
```

## Selecting a subset of the data frame using the \[ operator

Unlike `$` and `[[`, which return the value(s) contained in the specified element, `[` returns an object of the same type it is used to subset. Using `[` to retrieve the fifth column will return a data frame with 42 rows and 1 column. This may not seem like a big difference, but it can be an important distinction in some cases.

```{r, eval=FALSE}
birthweight[5]
```

```{r, echo=FALSE}
knitr::kable(
  birthweight[5],
  booktabs = TRUE,
  caption = 'Results of birthweight[5].'
) %>%
  kable_styling("striped") %>%
  scroll_box(height = "500px")
```

Because the `[` operator returns a new data frame, it can be used to specify multiple rows and / or columns.

```{r, eval=FALSE}
birthweight[c(1,5)]
```

```{r, echo=FALSE}
knitr::kable(
  birthweight[c(1,5)],
  booktabs = TRUE,
  caption = 'Results of birthweight[c(1,5)].'
) %>%
  kable_styling("striped") %>%
  scroll_box(height = "500px")
```
The `c()` function creates a vector. This allows R to treat indices 1 and 5 as a single argument. This is critical, because `birthweight[1,5]` does not produce the same effect at all.

```{r}
birthweight[1, 5]
```

What happened?

When there are two arguments provided to `[`, R interprets these as the index on the first (row) and second (column) dimension of the object. The value returned is the content of the first row, fifth column: the birth weight of individual 1107.

The default behavior of `[` is to return the entire object. The first argument acts as a sort of filter on the first dimension, the second argument as a filter on the second dimension, and so on. Leaving the space before the comma blank will return all rows (no filter applied), while leaving the space following the comma blank will return all columns. **Be sure to try variations on the example code below to see what happens.**

```{r, eval=FALSE}
birthweight[c(2,7,29), c(1,5)]
```

```{r, echo=FALSE}
knitr::kable(
  birthweight[c(2,7,29), c(1,5)],
  booktabs = TRUE,
  caption = 'Results of birthweight[c(2,7,29), c(1,5)].'
) %>%
  kable_styling("striped")
```

Using a minus sign before an index or group of indices will exclude the specified rows / columns.

```{r}
colnames(birthweight)
```
```{r, eval=FALSE}
# exclude paternal data (columns 13-16)
birthweight[c(1,3,5:13), -c(13:16)]
```
```{r, echo=FALSE}
knitr::kable(
  birthweight[c(1,3,5:13), -c(13:16)],
  booktabs = TRUE,
  caption = 'Results of birthweight[c(1,3,5:13), -c(13:16)].'
) %>%
  kable_styling("striped") %>%
  scroll_box(width = "100%", height = "500px")
```

R will also accept row or column names in quotations as a way to subset the data frame.

```{r, eval=FALSE}
birthweight[c("maternal.cigarettes", "birthweight")]
```
```{r, echo=FALSE}
knitr::kable(
  birthweight[c("maternal.cigarettes", "birthweight")],
  booktabs = TRUE,
  caption = 'Results of birthweight[c("maternal.cigarettes", "birthweight")].'
) %>%
  kable_styling("striped") %>%
  scroll_box(height = "500px")
```

Finally, vectors of logical (TRUE/FALSE) values can be used to subset data. Rows or columns corresponding to "TRUE" elements will be returned, while rows or columns corresponding to "FALSE" elements will be excluded.

```{r, eval=FALSE}
birthweight[c(1,3,5:13), c(TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, TRUE, TRUE)]
```

```{r, echo=FALSE}
knitr::kable(
  birthweight[c(1,3,5:13), c(TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, TRUE, TRUE)],
  booktabs = TRUE,
  caption = 'Results of birthweight[c(1,3,5:13), c(TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, TRUE, TRUE)].'
) %>%
  kable_styling("striped") %>%
  scroll_box(width = "100%", height = "500px")
```

This is *much* more useful than it may sound.

```{r}
birthweight$length
birthweight$length < 50
```

Since the result of the `birthweight$length < 50` operation is a vector of TRUE / FALSE values, it can be used to subset the data frame.

```{r, eval=FALSE}
birthweight[birthweight$length < 50, c(1,4:12,17,18)]
```
```{r, echo=FALSE}
knitr::kable(
  birthweight[birthweight$length < 50, c(1,4:12,17,18)],
  booktabs = TRUE,
  caption = 'Results of birthweight[birthweight$length < 50, c(1,4:12,17,18)].'
) %>%
  kable_styling("striped") %>%
  scroll_box(width = "100%", height = "500px")
```

### Subsetting a vector

A vector, like a column of a data frame, can be subsetted using the `[` operator with an index or another vector.

```{r}
birthweight$length[1]
birthweight$length[c(1,2)]
```

## Exercise 1: exploring the data

Use the `min()`, `max()`, and `mean()` functions on subsets of the data frame to answer one or more of the following questions. Work together. Often there will be more than one way to arrive at the answer.

- What is the range of paternal ages in the data set?
- What is the mean maternal age?
- What is the age of the mother with the highest maternal.cigarettes value?
- Is the mean pre-pregnant weight higher or lower among women who gave birth to low birth weight children?

What other questions are of interest to you? Can you answer any of them with the functions we have used so far?

# Basic data types

We have already said that logical values can be used to subset a data frame, and all the values in a given column of a data frame must be of the same type or *class*. But what does this mean?

## Understanding class

R has the following basic data classes:

-   numeric (includes integer and double)
-   character
-   logical
-   complex
-   raw

Generally, in bioinformatics, values belong to one of the first three classes. Read more about the complex and raw data types [here](https://r-coder.com/data-types-r/).

```{r}
class(birthweight$birthweight)
class(birthweight$smoker)
class(birthweight$geriatric.pregnancy)
```

"Numeric" is self-explanatory. What are character and logical?

Character values are exactly what they sound like: stored characters (letters and / or numbers). In the birthweight table, the "birth.date" and "location" columns contain character values.

```{r}
head(birthweight$location)
```

Characters are recognizable by the quotation marks that appear around them in the output. R cannot perform mathematical operations on numbers stored as characters. 

```{r, eval=FALSE}
1 + "1"
```

Logical values are TRUE, FALSE, or NA (missing). Logical values are the result of comparing one item to another with *relational operators*.

The relational operators in R are:

- `>` greater than
- `>=` greater than or equal to
- `<` less than
- `<=` less than or equal to
- `==` equal to
- `!=` not equal to

```{r, eval=FALSE}
birthweight[birthweight$head.circumference > 35, c("length", "weeks.gestation", "maternal.height", "paternal.height")]
```
```{r, echo=FALSE}
knitr::kable(
  birthweight[birthweight$head.circumference > 35, c("length", "weeks.gestation", "maternal.height", "paternal.height")],
  booktabs = TRUE,
  caption = 'Results of birthweight[birthweight$head.circumference > 35, c("length", "weeks.gestation", "maternal.height", "paternal.height")], c(1,4:12,17,18)].'
) %>%
  kable_styling("striped") %>%
  scroll_box(height = "500px")
```

```{r, eval=FALSE}
birthweight[birthweight$maternal.age <= 20, c("location", "maternal.age", "paternal.age")]
```
```{r, echo=FALSE}
knitr::kable(
  birthweight[birthweight$maternal.age <= 20, c("location", "maternal.age", "paternal.age")],
  booktabs = TRUE,
  caption = 'Results of birthweight[birthweight$maternal.age <= 20, c("location", "maternal.age", "paternal.age")].'
) %>%
  kable_styling("striped")

```

Notice that when R is asked to perform a comparison between a number and a missing value, the result is a missing value.

```{r, eval=FALSE}
birthweight[birthweight$paternal.education == 10, c(1,13:16)]
```
```{r, echo=FALSE}
knitr::kable(
  birthweight[birthweight$paternal.education == 10, c(1,13:16)],
  booktabs = TRUE,
  caption = 'Results of birthweight[birthweight$paternal.education == 10, c(1,13:16)].'
) %>%
    kable_styling("striped")
```

```{r}
birthweight[birthweight$weeks.gestation != 40, "weeks.gestation"]
```
```{r, eval=FALSE}
birthweight[birthweight$location == "General",]
```
```{r, echo=FALSE}
knitr::kable(
  birthweight[birthweight$location == "General",],
  booktabs = TRUE,
  caption = 'Results of birthweight[birthweight$location == "General",].'
) %>%
  kable_styling("striped") %>%
  scroll_box(width = "100%")
```

Many of R's functions also return logical values.

```{r}
is.numeric(birthweight$ID)
is.numeric(birthweight$smoker)
```

## Coercion: converting between classes

The birthweight data frame has three columns that should probably be logical values: "smoker", "low.birthweight", and "geriatric.pregnancy". All of these are questions that can be answered with TRUE/FALSE. However, only "geriatric.pregnancy" is stored as a logical value. Storing "smoker" and "low.birthweight" as logical values would be more useful, since it allows us to subset the data frame more easily.

Changing the class of data is known as *coercion*.

```{r}
as.logical(birthweight$low.birthweight)
as.logical(birthweight$smoker)
```

The `as.logical()` function converted "low.birthweight" to a logical vector, but could not convert "smoker," and returned a vector of missing data denoted by NA. Why is this?

The coercion rule in R is as follows:

logical \> integer \> numeric \> complex \> character

R can convert logical values to integers, store integers as the more general numeric type, or represent numeric data as a character, but these coercion operations cannot always be reversed without losing information.

```{r}
as.numeric(birthweight$geriatric.pregnancy)
```

The `as.logical()` function only operates on "low.birthweight" the way we want because the data was encoded as 0s and 1s. If *any other numbers* were used, the results might be unexpected.

```{r}
as.logical(birthweight$maternal.age)
```

Let's convert the "low.birthweight" column to logical.

```{r, eval=FALSE}
birthweight$low.birthweight <- as.logical(birthweight$low.birthweight)
birthweight
```
```{r, echo=FALSE}
birthweight$low.birthweight <- as.logical(birthweight$low.birthweight)
knitr::kable(
  birthweight,
  booktabs = TRUE,
  caption = 'The birthweight data frame.'
) %>%
  kable_styling("striped") %>%
  scroll_box(width = "100%", height = "500px")
```

Note that the output of `as.logical(birthweight$low.birthweight)` must be assigned to the "low.birthweight" column in order for the values in the column to change.

## Exercise 2: converting "smoker" from character to logical

Simple coercion is not going to convert the "smoker" column from character to logical.

**How can you solve this problem?**

# Functions

In the last section, you were asked to convert the "smoker" column to logical values. The solution is fairly simple:

```{r}
birthweight$smoker == "yes"
birthweight$smoker <- (birthweight$smoker == "yes")
```

```{r, eval=FALSE}
birthweight
```
```{r, echo=FALSE}
knitr::kable(
  birthweight,
  booktabs = TRUE,
  caption = 'The birthweight data frame.'
) %>%
  kable_styling("striped") %>%
  scroll_box(width = "100%", height = "500px")
```

Converting the dates (currently stored as characters) to a more usable format is not as simple, and will require a function.

R is filled with functions. We have already used a few: `read.csv()`, `class()`, `dim()`, `mean()`, `colnames()`, `as.logical()`, and `as.numeric()`. To find the documentation on a function, use the `?` character. This opens a page containing details on the function in the help pane.

## Basic functions

```{r}
?table
table(birthweight$geriatric.pregnancy, birthweight$low.birthweight)
```

Functions are invoked by name, with any arguments provided inside of parentheses. For example, the `chisq.test()` function, which runs a Chi-squared test, requires either a matrix or two vectors as arguments, and provides a number of options that may be set by the user.

```{r}
?chisq.test
chisq.test(birthweight$geriatric.pregnancy, birthweight$low.birthweight)
```

If no parameters are provided to the options, the default values are used. In some cases, this works well.

```{r}
mean(birthweight$birthweight[birthweight$geriatric.pregnancy])
# the ! character is used for negation
mean(birthweight$birthweight[!birthweight$geriatric.pregnancy])
```

Other times, it is necessary to adjust the options in order for a function to behave as you expect.

```{r}
mean(birthweight$paternal.age)
mean(birthweight$paternal.age, na.rm = TRUE)
sd(birthweight$paternal.age, na.rm = TRUE)
```

## Combining functions

The "birth.date" column is currently stored as a character vector. But what if we wanted to look at the birth weights of babies born in December? Let's split the day, month, and year into separate columns.

R has a function called `strsplit()`:

```{r}
?strsplit
strsplit(birthweight$birth.date, split = "/")
```

This is a good start. However, the output of `strsplit()` is a list containing 42 vectors of length 3, while the columns of birthweight are vectors of length 42.

**A note on lists:**

Lists are ordered collections of objects, which can be of any type. Unlike vectors, lists may contain elements of different types. To subset a list, use the `$` or `[[` operator.

The `unlist()` function will "flatten" a list into a vector.

```{r}
unlist(strsplit(birthweight$birth.date, split = "/"))
```

When functions are "nested," the operation in the innermost set of parentheses is performed first. In the example above, the `unlist()` function is applied to the output of `strsplit()`, changing a list to a vector. Since the goal was to split one column into three columns, this combination of functions is not effective.

We are going to need to *apply* some function to each item in the list that allows us to retrieve the first element of the vector.

## The apply() family of functions

One of the most useful groups of functions in R is the `apply()` family of functions. This group of functions execute a provided function on every element of a data structure.

**apply** takes a matrix, applies a function either by row or by column, and returns a vector.

```{r}
# by row
apply(birthweight[,c("maternal.cigarettes", "paternal.cigarettes")], 1, sum)
# by column
apply(birthweight[,c("maternal.cigarettes", "paternal.cigarettes")], 2, sum)
```

**mapply** takes a function and applies it to the elements of one or more vectors.

```{r}
mapply(sum, birthweight$maternal.cigarettes, birthweight$paternal.cigarettes)
```

**tapply** takes two vectors, applies a function to subsets of the first based on the categories in the second vector, and returns a table.

```{r}
tapply(birthweight$birthweight, birthweight$smoker, mean)
```

**lapply** takes a list, applies a function to each element, and returns a list.

**sapply** takes a list, applies a function to each element, and returns a list that has been simplified as much as possible.

```{r}
lapply(strsplit(birthweight$birth.date, split = "/"), '[[', 1)
sapply(strsplit(birthweight$birth.date, split = "/"), '[[', 1)
```

The result of this nested pair of functions is a vector of months encoded as numbers stored as characters.

## Custom functions

What if we want to do this for all three fields, but we don't want to write the code three times?

Take a few minutes to dissect the following function, working from the inside out. What does each piece do?

```{r}
# custom function takes a vector of dates and returns a data frame with columns day, month, and year
split_MMDDYYYY <- function(date_vector){
  date_list = lapply(seq(1:3), function(i){
    as.integer(sapply(strsplit(date_vector, split = "/"), '[[', i))
  })
  names(date_list) = c("month", "day", "year")
  as.data.frame(do.call("cbind", date_list))
}
```
```{r, eval=FALSE}
split_MMDDYYYY(birthweight$birth.date)
```
```{r, echo=FALSE}
knitr::kable(
  split_MMDDYYYY(birthweight$birth.date),
  booktabs = TRUE,
  caption = 'Results of split_MMDDYYYY(birthweight$birth.date).'
) %>%
  kable_styling("striped") %>%
  scroll_box(width = "100%", height = "500px")
```

```{r}
birthweight <- cbind(birthweight, split_MMDDYYYY(birthweight$birth.date))
```

The `cbind()` function combines objects by column. Now that we have the birth month in its own column, we can get the mean of birth weight by month.

```{r}
tapply(birthweight$birthweight, birthweight$month, mean)
```

## Exercise 3: summarizing the data

Pick one or more of the following questions to answer, or come up with one of your own. Work together. Once you've answered a question in one way, can you come up with alternate code that generates the same answer?

- Are preterm babies more likely to have low birth weight?
- What is the ratio of maternal cigarettes to paternal cigarettes for births at each of the hospitals?
- Do taller mothers have taller partners? Do they have longer babies?

## Merging data frames

For this example experiment, we also have placental miRNA expression data. These values are not from real samples, but have been manipulated to roughly reproduce the effect observed by [Maccani et al. 2010](https://www.tandfonline.com/doi/full/10.4161/epi.5.7.12762).

```{r}
download.file("https://raw.githubusercontent.com/ucdavis-bioinformatics-training/2022_February_Introduction_to_R_for_Bioinformatics/main/miRNA.csv", "miRNA.csv")
mir <- read.csv("miRNA.csv", row.names = 1)
```

```{r, eval=FALSE}
mir
```
```{r, echo=FALSE}
knitr::kable(
  mir,
  booktabs = TRUE,
  caption = 'The mir data frame.'
) %>%
  kable_styling("striped") %>%
  scroll_box(width = "100%", height = "500px")
```

In this object, the rows are the gene identifiers, and the columns are the samples.

```{r}
mir <- as.data.frame(t(mir))
mir$ID <- gsub("sample.", "", rownames(mir))
experiment <- merge(birthweight, mir)
```

What did these lines of code do? **Explore each of them**, looking up the function help using `?` as necessary.

```{r, eval=FALSE}
experiment
```

```{r, echo=FALSE}
knitr::kable(
  experiment,
  booktabs = TRUE,
  caption = 'The experiment data frame.'
) %>%
  kable_styling("striped") %>%
  scroll_box(width = "100%")
```

# Installing packages

All of the functions used up to this point were part of base R. They are built into the R language itself. Base R is extremely powerful, but R is also *extensible*. There are thousands of packages available for R.

The difficulty of installing these packages varies *greatly*. When possible, it is convenient to use [Bioconductor](https://www.bioconductor.org/), a repository of free, open source R software for bioinformatics, which is updated twice a year, and includes stable versions of R packages that are useful for biological and data science projects.

Bioconductor itself has an R package that manages installation and updates of the software contained in the repository.

```{r}
if (!("BiocManager" %in% rownames(installed.packages()))){
  install.packages("BiocManager")
}
if (!("ggplot2" %in% rownames(installed.packages()))){
  BiocManager::install("ggplot2")
}
if (!("tidyr" %in% rownames(installed.packages()))){
  BiocManager::install("tidyr")
}
if (!("dplyr" %in% rownames(installed.packages()))){
  BiocManager::install("dplyr")
}
if (!("magrittr" %in% rownames(installed.packages()))){
  BiocManager::install("magrittr")
}
if (!("viridis" %in% rownames(installed.packages()))){
  BiocManager::install("viridis")
}
```

# Introduction to the tidyverse

The [tidyverse](https://www.tidyverse.org/) is a collection of packages by the creators of RStudio that share an approach to data science.

The authors model data science like this:

![Data science life cycle](https://d33wubrfki0l68.cloudfront.net/571b056757d68e6df81a3e3853f54d3c76ad6efc/32d37/diagrams/data-science.png)

The tidyverse packages replace some of the base R functions with alternatives that are intended to be more user-friendly for data scientists who are following this life cycle.

We will only be covering a few of the packages from the tidyverse.

```{r}
library(tidyr)
library(dplyr)
library(magrittr)
```

## Defining tidy data

In "tidy" data, every column is a variable, every row is an observation, and every cell contains a single observation. Is the birthweight data frame tidy? Why or why not?

## Pipes: combining tidyverse functions

The tidyverse employs piping to send the output of one function to another function, rather than the nesting used in base r. The "pipe" is written with a greater than symbol sandwiched between two percent signs, like this: `%>%`.

```{r, eval=FALSE}
experiment %>%
  filter(low.birthweight == TRUE) %>%
  select(birth.date, length, birthweight, smoker)
```
```{r, echo=FALSE}
experiment %>%
  filter(low.birthweight == TRUE) %>%
  select(birth.date, length, birthweight, smoker) %>%
  kable(booktabs = TRUE,
        caption = 'Tidyverse filter and select.') %>%
    kable_styling("striped")
```
```{r, eval=FALSE}
# equivalent to:
experiment[experiment$low.birthweight == TRUE, c("birth.date", "length", "birthweight", "smoker")]
```
```{r, echo=FALSE}
knitr::kable(
  experiment[experiment$low.birthweight == TRUE, c("birth.date", "length", "birthweight", "smoker")],
  booktabs = TRUE,
  caption = 'Base R subsetting.'
) %>%
  kable_styling("striped")
```
## Transforming data

The `separate()` function makes the conversion of the "birth.date" column into "month," "day," and "year" trivial.

```{r, eval=FALSE}
experiment %>%
  filter(low.birthweight == TRUE) %>%
  select(birth.date, length, birthweight, smoker) %>%
  separate(col = birth.date, sep = "[/]", into = c("month", "day", "year"))
```
```{r, echo=FALSE}
experiment %>%
  filter(low.birthweight == TRUE) %>%
  select(birth.date, length, birthweight, smoker) %>%
  separate(col = birth.date,
           sep = "[/]",
           into = c("month", "day", "year")) %>%
  kable(booktabs = TRUE,
        caption = 'Tidyverse separate.') %>%
  kable_styling("striped")
```

The `mutate()` function adds a new column based on data contained in the existing columns.

```{r, eval=FALSE}
experiment %>%
  filter(low.birthweight == TRUE) %>%
  select(birth.date, length, birthweight, smoker) %>%
  mutate(d = birthweight / length)
```
```{r, echo=FALSE}
experiment %>%
  filter(low.birthweight == TRUE) %>%
  select(birth.date, length, birthweight, smoker) %>%
  mutate(d = birthweight / length) %>%
  kable(booktabs = TRUE,
        caption = 'Tidyverse mutate.') %>%
  kable_styling("striped")
```

## Summarizing data

The `group_by()` and `summarize()` functions apply a function to a group defined by one or more categorical variables.

```{r, eval=FALSE}
experiment %>%
  group_by(smoker) %>%
  summarize(mean.birthweight = mean(birthweight))
```
```{r, echo=FALSE}
experiment %>%
  group_by(smoker) %>%
  summarize(mean.birthweight = mean(birthweight)) %>%
  kable(booktabs = TRUE,
        caption = 'Tidyverse summarize grouped by smoker.')
```
```{r, eval=FALSE}
experiment %>%
  group_by(smoker, low.birthweight) %>%
  summarize(mean.birthweight = mean(birthweight))
```
```{r, echo=FALSE}
experiment %>%
  group_by(smoker, low.birthweight) %>%
  summarize(mean.birthweight = mean(birthweight)) %>%
  kable(booktabs = TRUE,
        caption = 'Tidyverse summarize grouped by smoker and birthweight.')
```

To change the order of rows, use `arrange()`. To return one or more specified rows, use `slice()`.

```{r, eval=FALSE}
experiment %>%
  group_by(smoker) %>%
  select(smoker, birthweight, length, head.circumference, weeks.gestation) %>%
  slice_max(order_by = birthweight, n = 5)
```

```{r, echo=FALSE}
experiment %>%
  group_by(smoker) %>%
  select(smoker, birthweight, length, head.circumference, weeks.gestation) %>%
  slice_max(order_by = birthweight, n = 5) %>%
  kable(booktabs = TRUE,
        caption = 'Tidyverse slice, ordered on birthweight.')
```

The `pivot_longer()` and `pivot_wider()` functions rearrange data, decreasing or increasing the number of columns. The use of this will become more evident during visualization.

```{r, eval=FALSE}
experiment %>%
  filter(low.birthweight == TRUE) %>%
  select(smoker, `miR-16`, `miR-21`, `miR-146a`, `miR-182`) %>%
  pivot_longer(cols = c(`miR-16`, `miR-21`, `miR-146a`, `miR-182`),
               names_to = "gene",
               values_to = "expression") 
```

```{r, echo=FALSE}
experiment %>%
  filter(low.birthweight == TRUE) %>%
  select(smoker, `miR-16`, `miR-21`, `miR-146a`, `miR-182`) %>%
  pivot_longer(cols = c(`miR-16`, `miR-21`, `miR-146a`, `miR-182`),
               names_to = "gene",
               values_to = "expression") %>%
  kable(booktabs = TRUE,
        caption = 'Tidyverse pivot_longer.') %>%
  kable_styling("striped") %>%
  scroll_box(height = "500px")
```

## Exercise 4: converting between base R and Tidyverse

Reproduce one of the summary tables using base R. Use Tidyverse functions to answer the question you addressed in exercise 3.

# Visualizations

```{r, include=FALSE}
knitr::opts_chunk$set(
  fig.path = "./figures/"
)
```

The ggplot2 library is an extremely popular visualization package that provides an interface for extremely fine control over graphics for plotting. It is used by a number of of other popular packages in their built-in plotting functions. It provides a "grammar of graphics" that is quite useful to know.

**A note about accessibility:**

The default colors automatically selected by ggplot2 are not very user-friendly. Colors are chosen by sampling evenly spaced hues on the color wheel. Because of this behavior, all of the colors have similar intensity, which means that they do not work well when printed in gray-scale, and may be difficult to distinguish for users with atypical color vision. There are many resources for selecting color palettes online. Here are just a few:

- [Viridis](https://cran.r-project.org/web/packages/viridis/vignettes/intro-to-viridis.html)
- [ColorBrewer](https://colorbrewer2.org/#type=sequential&scheme=BuGn&n=3)
- [colorBlindness Guide](https://cran.r-project.org/web/packages/colorBlindness/vignettes/colorBlindness.html#Collection_of_safe_colors)
- [Digital Accessibility](https://accessibility.digital.gov/visual-design/color-and-contrast/)
- [Blog entry](https://personal.sron.nl/~pault/)

In this documentation we will be using four palettes generated using the viridis library.

```{r}
library(ggplot2)
library(viridis)
?viridis

locations.palette <- viridis(3)
smoking.palette <- inferno(2, begin = 0.5, direction = -1)
years.palette <- mako(2, begin = 0.4, end = 0.9, direction = -1)
genes.palette <- plasma(4)
```

As we go through this plotting section, we will pause several times to allow you to explore. Don't limit yourself to the visualizations included! Experiment with manipulating each of the elements of the plots to achieve interesting and informative graphics.

## The ggplot() function

The basic function of the ggplot2 library is `ggplot()`.

```{r}
?ggplot
```

It is capable of taking a lot of arguments and options, but requires only two: an object (typically a data frame) containing the data, and a list of "aesthetic mappings" that tell R which values to use for the axes, colors, and other graphical elements of the plot.

```{r, blank}
ggplot(data = experiment, mapping = aes(x = birthweight))
```

Alone, this produces an empty plot. The `ggplot()` function by itself creates the blank canvas upon which the plot will be drawn. The plot elements are added to this canvas in layers called "geoms."

## The geom

There are over 30 geoms in the ggplot2 library, each of which accepts a particular set of aesthetic mappings. The geoms inherit the mapping specified in the original `ggplot()` function call, and additional layer-specific aesthetics may be specified within the geom. Let's start with one of the simplest geoms, the histogram.

The `geom_histogram()` function requires, at a minimum, that a value be provided for x.

```{r, histogram}
ggplot(data = experiment, mapping = aes(x = birthweight)) +
  geom_histogram()
```

Setting the "binwidth" parameter within the `geom_histogram()` call changes the appearance of the plot and eliminates the message.

```{r, bindwidth}
ggplot(data = experiment, mapping = aes(x = birthweight)) +
  geom_histogram(binwidth = 1)
ggplot(data = experiment, mapping = aes(x = birthweight)) +
  geom_histogram(binwidth = 0.25)
```

## Adding color (and fill) to geoms

The color (for lines and points) and fill (for areas, like bars) of a geom can add another layer of information to the plot.

```{r, fill}
ggplot(data = experiment, mapping = aes(x = birthweight, fill = location)) +
  geom_histogram(binwidth = 0.25) +
  scale_fill_manual(values = locations.palette) 
```

Here the total height of the bar is equal to the number of births at each weight, and the fill denotes the hospital at which the birth occurred.

```{r}
ggplot(data = experiment, mapping = aes(x = birthweight, fill = location)) +
  geom_histogram(binwidth = 0.25, position = position_dodge()) +
  scale_fill_manual(values = locations.palette)
```

To un-stack the bars, use "position_dodge."

## Creating faceted plots

Sometimes, it may be more clear graphically to create multiple sub-plots or "facets" based on categorical values in the data. The `facet_wrap()` and `facet_grid()` functions allow the user to break the data down into multiple plots by one or two categorical variables, respectively.

```{r, facet}
ggplot(data = experiment, mapping = aes(x = birthweight, fill = location)) +
  geom_histogram(binwidth = 0.25) +
  scale_fill_manual(values = locations.palette) +
  facet_wrap(~year, nrow = 2)
```

## Add and modify labels

Often, the aesthetic names (column names) are uninformative, or unattractive. This may not make much difference when making exploratory figures, but in a report or publication, it is important to have a greater degree of control over the plot title, axis labels, and so on. The `labs()` function offers the option to set the following labels:

- **any aesthetic that has been set**: in this case, x and fill 
- **title**: main title of the plot
- **subtitle**: displayed below the title
- **caption**: displayed at the bottom right of the plot by default
- **tag**: label that appears at the top left of the plot by default (e.g. 1A)
- **alt**, **alt_insight**: alt text for the plot (used by screen readers)

```{r, labs}
ggplot(data = experiment, mapping = aes(x = birthweight, fill = location)) +
  geom_histogram(binwidth = 0.25) +
  scale_fill_manual(values = locations.palette) +
  facet_wrap(~year, nrow = 2) +
  labs(x = "birth weight (kg)",
       fill = "Hospital",
       tag = "fig. 1",
       caption = "Birth weights by year, color-coded by delivery location.",
       alt = "Pair of histograms displaying the distribution of birth weights of infants born at General Hospital, Memorial Hospital, and Silver Hill Medical Center in 1967 and 1968.")
```

## Making global changes to the plot's appearance using themes

The "theme" of a ggplot object controls the graphical elements that are not mapped onto the data. This includes things like the font size and alignment of axis labels and the color of the plot background. There are a number of pre-set themes offering a range of plot styles.

In addition, the `theme()` function offers access to these graphical elements independently. Using it, you can change the angle of the text on the x axis, the placement of the legend, and many other things. Here, we will use it to remove the legend title.

```{r, theme}
ggplot(data = experiment, mapping = aes(x = birthweight, fill = location)) +
  geom_histogram(binwidth = 0.25) +
  scale_fill_manual(values = locations.palette) +
  facet_grid(location~year) +
  labs(x = "weight (kg)", y = "births") +
  theme_bw() +
  theme(legend.title = element_blank())
```

An interesting alternative to `geom_histogram()` is `geom_density()`.
```{r, density}
ggplot(data = experiment, mapping = aes(x = birthweight, fill = smoker)) +
  geom_density(alpha = 0.5) +
  scale_fill_manual(values = smoking.palette) +
  labs(x = "birth weight (kg)", fill = "Maternal smoking in pregnancy") +
  theme_bw()
```

The alpha channel of a color determines its opacity. In this case, we have placed `alpha = 0.5` outside of the `aes()` function call, because the opacity is not being mapped to any characteristic of the data.

The examples above use color in a discrete fashion. In the scatter plot below, the color of each point represents a birth weight (continuous variable).

```{r, point}
experiment %>%
  filter(smoker == TRUE) %>%
  ggplot(mapping = aes(x = maternal.cigarettes,
                       y = weeks.gestation,
                       color = birthweight)) +
  geom_point()  +
  labs(x = "Maternal cigarettes / day", y = "Gestational age at birth (weeks)", color = "Birth weight (kg)") +
  scale_color_viridis(option = "inferno", begin = 0.4) +
  theme_bw()
```

Notice that it is not necessary to specify a color palette; viridis has a built-in function for interacting with ggplot objects.

## Change the labels for categorical values

All of the elements of the plot, not just the height of bars and position of points, convey information. The labels on a categorical axis should be meaningful.

```{r, box}
experiment %>%
  ggplot(mapping = aes(x = smoker, y = birthweight, fill = smoker)) +
  geom_boxplot() +
  scale_fill_manual(values = smoking.palette) +
  theme_bw()
```

The bar chart above displays the values "TRUE" and "FALSE" on the x-axis. This is fine for an exploratory plot, but in a report or publication, it might be more informative to replace them with "smoker" and "non-smoker." The `scale_x_discrete()` function allows us to do just that.

```{r, scale_x_discrete}
experiment %>%
  ggplot(mapping = aes(x = smoker, y = birthweight, fill = smoker)) +
  geom_boxplot() +
  scale_fill_manual(values = smoking.palette) +
  scale_x_discrete(labels = c("non-smoker", "smoker")) +
  guides(fill = "none") +
  labs(y = "birth weight (kg)", x = "maternal cigarette use in pregnancy") +
  theme_bw()
```

## Change the direction of axes to improve readability

If the category names are very long, it may be necessary to change the direction of the axis labels.

```{r, element_text}
experiment %>%
  ggplot(mapping = aes(x = smoker, y = birthweight, fill = smoker)) +
  geom_boxplot() +
  scale_fill_manual(values = smoking.palette) +
  scale_x_discrete(labels = c("non-smoking in pregnancy", "cigarette smoking in pregnancy")) +
  guides(fill = "none") +
  labs(y = "birth weight (kg)") +
  theme_bw() +
  theme(axis.title.x = element_blank(),
        axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))
```

Or even the direction of the axes themselves.

```{r, coord_flip}
experiment %>%
  ggplot(mapping = aes(x = smoker, y = birthweight, fill = smoker)) +
  geom_boxplot() +
  scale_fill_manual(values = smoking.palette) +
  scale_x_discrete(labels = c("non-smoking in pregnancy", "cigarette smoking in pregnancy")) +
  guides(fill = "none") +
  labs(y = "birth weight (kg)") +
  coord_flip() +
  theme_bw() +
  theme(axis.title.y = element_blank())
```

## The pivot_longer() function revisited

In the previous section on Tidyverse, `pivot_longer()` was only briefly discussed. This is because the easiest way to explain *why* it is useful is to demonstrate.

```{r, pivot_longer}
experiment %>%
  pivot_longer(cols = c(22:25),
               names_to = "gene.id",
               values_to = "expression") %>%
  ggplot(mapping = aes(x = smoker, y = expression, fill = smoker)) +
  geom_violin() +
  scale_fill_manual(values = smoking.palette) +
  scale_x_discrete(labels = c("non-smoker", "smoker")) +
  facet_wrap(~ gene.id, nrow = 2) +
  guides(fill = "none") +
  labs(x = "Maternal tobacco use in pregnancy", y = "miRNA expression") +
  theme_bw()
```

After pivoting the miRNA data into a single column called expression, that data is available for ggplot to map that onto an aesthetic property.

## Use shape and line type to convey meaning

Color is not the only aesthetic available for mapping to the data. Shape and line type are also good candidates for displaying categorical (or discrete) values.

```{r, shape}
experiment %>%
  pivot_longer(cols = c(22:25),
               names_to = "gene.id",
               values_to = "expression") %>%
  ggplot(mapping = aes(x = maternal.cigarettes, y = expression, color = location, shape = low.birthweight)) +
  geom_point() +
  scale_color_manual(values = locations.palette) +
  scale_shape_manual(values = c(16, 17), labels = c("< 2.72 kg", ">= 2.72 kg")) +
  facet_wrap(~ gene.id, nrow = 2) +
  labs(x = "Maternal cigarettes / day", y = "miRNA expression") +
  theme_bw() +
  theme(legend.title = element_blank())
```

There are 25 shapes available for plotting. You can see them all [here](http://www.sthda.com/english/wiki/ggplot2-point-shapes).

```{r, linetype}
experiment %>%
  ggplot(mapping = aes(x = weeks.gestation, y = birthweight, linetype = smoker)) +
  geom_quantile(quantiles = c(0.25, 0.5, 0.75), color = "black") +
  labs(x = "gestational age at birth", y = "birth weight (kg)", linetype = "geriatric preganancy") +
  theme_bw()
```

## Focus in on one portion of the plot

We can zoom in to the the lower left hand corner of the plot using `coord_cartesian()`.

```{r, coord_cartesian}
experiment %>%
  ggplot(mapping = aes(x = weeks.gestation, y = birthweight, linetype = smoker)) +
  geom_quantile(quantiles = c(0.25, 0.5, 0.75), color = "black") +
  labs(x = "gestational age at birth", y = "birth weight (kg)", linetype = "geriatric preganancy") +
  coord_cartesian(xlim = c(33, 35), ylim = c(1.5, 3.5)) +
  theme_bw()
```

## Layer multiple geoms

It is not necessary to make a single geom convey all of the information a plot must communicate. Instead, ggplot2 offers users the ability to layer geoms together. As long as they use the same axes, geoms may share a plot.

```{r, smooth}
ggplot(experiment, mapping = aes(x = weeks.gestation,
                                 y = birthweight,
                                 color = smoker)) +
  geom_point() +
  geom_smooth(alpha = 0.2) +
  labs(x = "Gestational age at birth (weeks)",
       y = "Birth weight (kg)",
       color = "Maternal tobacco use",
       caption = "Birthweight increases with gestational age for infants born to both\nsmokers and non-smokers.") +
  scale_color_manual(values = smoking.palette) +
  theme_bw() +
  theme(plot.caption = element_text(hjust = 0))
experiment %>%
  group_by(year, smoker) %>%
  summarise(mean.birthweight = mean(birthweight),
            sd.birthweight = sd(birthweight)) %>%
  ggplot(mapping = aes(x = as.factor(year), y = mean.birthweight, fill = smoker)) +
  geom_col(position = position_dodge2(preserve = "single")) +
  geom_errorbar(mapping = aes(ymin = mean.birthweight - sd.birthweight,
                              ymax = mean.birthweight + sd.birthweight),
                position = position_dodge2(preserve = "single")) +
  scale_fill_manual(values = smoking.palette) +
  labs(x = "birth year", y = "birth weight (kg)", fill = "maternal smoking") +
  theme_bw()
```

## ggplot2 cheat sheet

For more information on ggplot2 check out this [quick reference guide](https://www.rstudio.com/resources/cheatsheets/), and the [free online book](https://ggplot2-book.org/).

## Exercise 5

Create a visualization that provides an answer to one of the following questions:

- Are preterm babies more likely to have low birth weight?
- What is the ratio of maternal cigarettes to paternal cigarettes for births at each of the hospitals?
- Do taller mothers have taller partners? Do they have longer babies?

# Troubleshooting

Even advanced users of R run into problems often. Here are some of the most common errors that can often be resolved quickly:

- file is not in the right place, or is incorrectly named
- improperly formatted files
- missing values
- spelling errors
- incorrectly named parameters

For more complex errors, the help documentation of a function is a good place to start. Additionally, the online community of R users is extremely active and helpful. If you've got a question, it's extremely likely it's been asked and answered many times already!

